"""
BOJ5639.
[문제]
이진 검색 트리는 다음과 같은 세 가지 조건을 만족하는 이진 트리이다.

* 노드의 왼쪽 서브트리에 있는 모든 노드의 키는 노드의 키보다 작다.
* 노드의 오른쪽 서브트리에 있는 모든 노드의 키는 노드의 키보다 크다.
* 왼쪽, 오른쪽 서브트리도 이진 검색 트리이다.

전위 순회 (루트-왼쪽-오른쪽)은 루트를 방문하고, 왼쪽 서브트리, 오른쪽 서브 트리를 순서대로 방문하면서 노드의 키를 출력한다. 후위 순회 (왼쪽-오른쪽-루트)는 왼쪽 서브트리, 오른쪽 서브트리, 루트 노드 순서대로 키를 출력한다. 예를 들어, 위의 이진 검색 트리의 전위 순회 결과는 50 30 24 5 28 45 98 52 60 이고, 후위 순회 결과는 5 28 24 45 30 60 52 98 50 이다.

이진 검색 트리를 전위 순회한 결과가 주어졌을 때, 이 트리를 후위 순회한 결과를 구하는 프로그램을 작성하시오.

[입력]
트리를 전위 순회한 결과가 주어진다. 노드에 들어있는 키의 값은 106보다 작은 양의 정수이다. 모든 값은 한 줄에 하나씩 주어지며, 노드의 수는 10,000개 이하이다. 같은 키를 가지는 노드는 없다.

[출력]
입력으로 주어진 이진 검색 트리를 후위 순회한 결과를 한 줄에 하나씩 출력한다.
"""

import sys
sys.setrecursionlimit(10**9) # 노드 수가 최대 10,000개이므로 깊은 재귀 호출 대비(이렇게 하는 거 처음 알았다...)

# 전위 순회 결과를 이용해 BST를 구성하고 후위 순회 출력
def postorder(start, end):

    # 현재 구간이 비면(노드가 없으면) 종료
    if start > end:
        return

    # 전위 순회의 첫 번째 원소가 현재 서브트리의 루트
    root = preorder[start]

    # 오른쪽 서브트리 시작 인덱스 찾기
    idx = start + 1
    while idx <= end and preorder[idx] < root: # 루트보다 큰 값이 처음 나오는 위치 = 오른쪽 서브트리의 시작점
        idx += 1

    # 왼쪽 서브트리
    postorder(start + 1, idx - 1)
    # 오른쪽 서브트리
    postorder(idx, end)
    # 루트 출력
    print(root)


# 입력 받기
preorder = []
for line in sys.stdin:
    line = line.strip()
    if not line: # 입력이 없으면 입력을 받는 것을 종료
        break
    preorder.append(int(line)) # 입력을 preorder 리스트 안에 순서대로 입력

N = len(preorder)

# 후위 순회 실행
postorder(0, N - 1)
